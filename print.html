<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Majestic Lisp</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="teste.html"><strong aria-hidden="true">1.</strong> Teste</a></li><li class="chapter-item expanded "><a href="00-agradecimentos.html"><strong aria-hidden="true">2.</strong> Agradecimentos</a></li><li class="chapter-item expanded "><a href="01-introducao.html"><strong aria-hidden="true">3.</strong> Introdução</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01-01-o-que-e-lisp.html"><strong aria-hidden="true">3.1.</strong> O que é Lisp?</a></li><li class="chapter-item expanded "><a href="01-02-majestic-lisp.html"><strong aria-hidden="true">3.2.</strong> Majestic Lisp</a></li><li class="chapter-item expanded "><a href="01-03-sobre-programacao-instruida.html"><strong aria-hidden="true">3.3.</strong> Sobre Programação Instruída</a></li><li class="chapter-item expanded "><a href="01-04-como-ler-este-documento.html"><strong aria-hidden="true">3.4.</strong> Como ler este documento</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Majestic Lisp</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="testando-a-exportação"><a class="header" href="#testando-a-exportação">Testando a Exportação</a></h1>
<p>Exportação.</p>
<pre><code class="language-C">#include &lt;u.h&gt;
#include &lt;libc.h&gt;

void
main()
{
    print(&quot;Hello, world!\n&quot;);
    exits(0);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="agradecimentos"><a class="header" href="#agradecimentos">Agradecimentos</a></h1>
<p>A linguagem construída nesse livro dá ao leitor a ideia de um software primariamente artesanal, o que leva à crença de que Majestic Lisp seja o &quot;esforço de um homem só&quot;. De fato, a maior parte dessa obra foi realizada em momentos solitários e muitas noites e madrugadas de insônia e muito café. Todavia, esta não é toda a história.</p>
<p>Nenhuma obra pode ser concebida apenas com o esforço de uma pessoa. Mais especificamente, seria impossível realizar um esforço tão audacioso quanto um livro que ensina como programar uma linguagem de programação, usando apenas o conhecimento contido em uma mente – que, por definição, é extremamente limitado.</p>
<p>Por esse motivo, gostaria de agradecer a algumas pessoas que me ajudaram ou ajudam ao longo da escrita desse projeto; se fosse possível dizer que uma parte de mim viveria, para a posterioridade, nesta obra, então certamente parte dessas outras pessoas sofreria o mesmo destino.</p>
<p>Obrigado a Paul Graham, criador da linguagem Bel, que serviu de inspiração direta para Majestic Lisp. Se Bel não tivesse sido criada, a possibilidade da criação de Majestic Lisp não teria surgido em primeiro lugar.</p>
<p>Obrigado a Jerônimo Pellegrini, que muito me forneceu recomendações e orientações a respeito da forma como linguagens da família Lisp são programadas. Ainda que não tenha seguido seus conselhos à risca, isso tornou Majestic Lisp uma linguagem melhor.</p>
<p>Obrigado aos meus amigos da comunidade Rust Brasil: Elias, Bruno, Tiago, Renan, e muitos outros mais a quem recorri ao discutir sobre aspectos em especial da linguagem, bem como recorri na necessidade de conselhos sobre implementação desse projeto na linguagem Rust.</p>
<p>Finalmente, sem menos importância, obrigado ao Manoel, ao Edgard; novamente ao Renan e ao Jerônimo, e também aos demais amigos da comunidade Common Lisp Brasil, onde tudo se discute, o que inclui tecnologia em geral e outros dialetos de Lisp. Ali mesmo foi o berçário de Majestic; ali se criou, muito antes da linguagem Bel, o embrião do que seria um Lisp baseado em algumas das minhas opiniões, ainda que muitas vezes infundadas.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introdução"><a class="header" href="#introdução">Introdução</a></h1>
<p>Programação pode ser considerada um trabalho majoritariamente artesanal. Mas uma consideração como essa não é adotada de forma predominante; longe disso, torna-se algo digno de debate, e deixa uma margem para uma interessante troca de opiniões divergentes. Há aqueles que pensem no ato de escrever um programa de computador como algo mecânico em princípio: existiria um quê de criatividade, já que o programador precisa tomar as melhores decisões do ponto de vista do projeto de <em>software</em>; Mas, para tal, enumera-se ferramentas e processos que o auxiliam com planejamento e que, muitas vezes, acabam apontando, sem auxílio de ``intuição'', o melhor caminho a ser seguido nesse processo criativo.</p>
<p>Apesar de ver a pertinência do uso desses processos (como nos apresenta a disciplina de <em>Engenharia de Software</em>, por exemplo), ainda acredito na programação de computadores como uma <em>arte</em>, algo que envolve muito mais que apenas seguir práticas consolidadas.</p>
<p>&lt;&amp;verna2018&gt; (p. 4) endossa o aspecto artístico na programação – que, por alguns, é considerado mera luxúria –, inclusive citando antigos apoiadores dessas ideias (como Knuth, Dijkstra e Ershov). Esses pensadores ilustres também buscavam clarificar que a descrição de um programa de computador envolve noções intrínsecas de <em>estética</em>, <em>beleza</em>, <em>estilo</em>, <em>prazer</em> e <em>emoção</em>, que tendem a pender muito mais para o lado artístico que o científico.</p>
<p>Penso na escrita de um código de programação como sendo um processo muito similar à boa escrita em prosa de qualquer outro tipo de texto. O objetivo do autor é fazer-se entender através do que escreve; para tanto, é imperativo que palavras, orações e demais expressões gramaticais sejam ordenadas de forma inteligível, e o melhor recurso para garantir que o leitor compreenda o texto escrito é a própria leitura do mesmo, especialmente quando é feita por parte do autor.</p>
<p>Ao escrevermos um programa de computador, realizamos um processo muito similar à composição ou redação. A escrita do código acaba, no fim das contas, por envolver três leitores: o <em>próprio autor</em>, um eventual <em>futuro leitor</em> do código e a <em>máquina</em> em si (leia-se, o compilador ou interpretador, que fica efetivamente responsável por ``compreender'' o código em questão e transformá-lo em linguagem de máquina).</p>
<p>O ``leitor'' mais fácil de agradar neste trio é a <em>máquina</em>, que não reclamará de aspectos como a estética do código, salvo quando programas como <em>linters</em> forçarem um certo estilo de escrita no processo de programação. Porém, a <em>máquina</em> ainda está suscetível a erros gramaticais ou de interpretação, provenientes de deficiências na escrita do código: estes poderão ocasionar tanto erros que antecedem a execução (quando tratarem-se de código sintaticamente inválido), quanto a execução de algo não-pretendido pelo programador (sendo este o caso do erro de semântica).</p>
<p>Aqui entra em ação outro potencial leitor do código: o próprio <em>autor</em>, o programador daquele segmento de código em si. O programador precisa verificar o código por erros, e também precisa criar correções. Se a forma como o código foi escrito não facilita o próprio trabalho daquele que o escreveu, então é sinal de que é necessário revisar a forma como o mesmo foi escrito. Escrever código sem preocupar-se com estética ou beleza é um erro comum de muitos programadores, que costumam ignorá-lo por não representar um problema em curto prazo. Mas, se aquele código precisar ser revisitado após algum tempo, o programador será o primeiro a sofrer com as consequências da ilegibilidade e/ou desorganização do próprio trabalho.</p>
<p>Por fim, temos o último tipo de leitor: o <em>futuro leitor</em> do código, que normalmente seria um terceiro; mas poderíamos pensar até mesmo no programador original, passado um bom tempo desde a última vez que viu o código: aos seus olhos, o programa ter-se-á tornado algo completamente desconhecido… um alienígena.</p>
<p>Precisamos pensar no código como uma ferramenta <em>didática</em>. O código precisa ser dotado de uma simplicidade autoexplicativa. O <em>futuro leitor</em> precisará consertar algo no mesmo ou adicionar uma nova funcionalidade; para tanto, a forma de escrever o código será o melhor guia para deixá-lo a par dos passos a serem tomados, ou dos processos a serem seguidos para adicionar, remover ou modificar certas operações.</p>
<p>No espírito deste <em>aspecto didático</em> do código, que requer certa elegância e senso de beleza, é que escrevo este pequeno <em>software</em> em formato de livro. Escrever o interpretador de uma linguagem de programação e definir a especificação da mesma não é uma tarefa trivial, mas é uma tarefa <em>tangível</em>. Para provar esse argumento e também para encorajar outros programadores a utilizarem-se dessas ideias, detalho passo-a-passo todo o raciocínio por trás do planejamento para que se conceba uma linguagem de programação – como um caso especial, uma linguagem que seja um dialeto de Lisp.</p>
<p>A intenção não é apresentar um produto que seja extremamente polido e que não possa ser modificado posteriormente; antes, o <em>software</em>, assim como qualquer outro texto, é algo <em>vivo</em>, e pode inclusive ser modificado, melhorado ou até mesmo ``traduzido'' para outras linguagens. Por isso, trabalho sob alguns pressupostos, que mais tarde enumerarei, e que segui como regras informais de estilo para esse processo de desenvolvimento.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="o-que-é-lisp"><a class="header" href="#o-que-é-lisp">O que é Lisp?</a></h1>
<p>Antes de mais nada, é essencial ressaltar que a linguagem que construiremos ao longo desse texto é um dialeto de Lisp.</p>
<p>LISP, acrônimo para <em>List Processor</em> (processador de listas), é um formalismo inicialmente definido por <mccarthy1960>, e então polido até tornar-se uma linguagem de programação propriamente dita. Posteriormente, essa linguagem seria lançada como LISP 1.5.</p>
<p>Sendo LISP um <em>processador de listas</em>, há uma pretensão de que o usuário possa usufruir de uma situação inusitada: tanto <em>código</em> quanto <em>dados</em> poderiam ser expressados sob a mesma estrutura, uma <em>lista simplesmente encadeada</em> <cormen-pt>.</p>
<p>Desde o lançamento do LISP 1.5 de McCarthy, a linguagem acabou por tornar-se uma família de linguagens, dotada de diversos dialetos, cada qual com suas idiossincrasias. Mas a maioria deles acabou conservando a característica de expressar diretamente as listas em seus códigos, em uma sintaxe que chamamos de <em>s-expressions</em>. Por isso, dialetos de Lisp normalmente possuem a característica de serem dotados de muitos parênteses na escrita.</p>
<center>
<p><img src="./img/Symbolics3640.png" alt="img" /></p>
<p><small>Symbolics 3640 Lisp Machine.  Fonte: https://en.wikipedia.org/wiki/Lisp_machine. Acesso em 12/09/2020.</small></p>
</center>
<p>Muitos dialetos de Lisp tornaram-se populares ao longo da história, inclusive em máquinas comerciais feitas exclusivamente para execução de Lisps, comumente chamadas de <em>Lisp Machines</em>. Nessas máquinas otimizadas para computação simbólica e processamento de listas, todo o sistema operacional era construído usando-se um dialeto de Lisp. Os sistemas incluíam programas extras como um editor de texto vinculado ao sistema, por exemplo. Através do próprio editor de texto, pode-se realizar alterações com impacto em todo o sistema operacional.</p>
<center>
<p><img src="img/zmacs.png" alt="img" title="Editor de texto Zmacs, editor do TI Explorer." /></p>
<p><small>Editor de texto Zmacs, editor do TI Explorer. Fonte: https://alchetron.com/Zmacs. Acesso em 18/09/2020.</small></p>
</center>
<p>Apesar dos mais de 50 anos de idade de LISP 1.5, os dialetos de Lisp não deixaram de ter sua popularidade, ainda que modesta. Há muitos dialetos de Lisp modernos, como podemos verificar a seguir.</p>
<p>O dialeto Common Lisp possui implementações com compiladores nativos, tendo sua performance comparável a linguagens como C e C++. As implementações mais maduras vêm também acompanhadas de um sistema de orientação a objetos poderoso, com despacho de métodos baseado em tipos, e também de um sistema maduro de condições que permite recuperar-se de erros imprevistos manualmente, enquanto o programa é executado.</p>
<pre><code class="language-lisp">(defun say-hello (name)
  (format t &quot;Hello, ~a!~%&quot; name))

(say-hello &quot;Fulano&quot;)
</code></pre>
<center><small>Exemplo de código em Common Lisp.</small></center>
<p>A linguagem Scheme é uma linguagem simples, com uma especificação sucinta. Sendo o carro-chefe dos exemplos explicados em <sicp>, é uma excelente escolha para iniciantes, sobretudo para aqueles que querem melhor entender o paradigma da <em>programação funcional</em>. Sua contraparte – a linguagem Racket, por vezes figurada como um dialeto de Scheme – é como Scheme com ``pilhas incluídas'', possuindo até mesmo um <em>ambiente integrado de desenvolvimento</em> (IDE) próprio, sendo um ambiente propício até mesmo para iniciantes na programação de computadores.</p>
<pre><code class="language-scheme">(define (say-hello name)
  (display &quot;Hello, &quot;)
  (display name)
  (newline))

(say-hello &quot;Fulano&quot;)
</code></pre>
<center><small>Exemplo de código em Scheme.</small></center>
<p>A linguagem Clojure foi criada por Rich Hickey para ser compatível com a máquina virtual da linguagem Java – a JVM. Atualmente possui grande uso comercial, sendo um dos maiores incentivos para o aprendizado da <em>programação funcional</em>. Sua flexibilidade auxilia inclusive na operabilidade entre programas em Clojure e bibliotecas anteriormente escritas em Java. Possui uma contraparte chamada ClojureScript, que pode ser usada para desenvolvimento web Frontend.</p>
<pre><code class="language-clojure">(defn say-hello [name]
  (format &quot;Hello, %s!\n&quot; name))

(say-hello &quot;Fulano&quot;)
</code></pre>
<center><small>Exemplo de código em Clojure.</small></center>
<p>O dialeto Emacs Lisp é utilizado como linguagem de <em>script</em> no editor de texto Emacs. Muito similar a Common Lisp, porém com algumas diferenças bem profundas, permite um nível de modificação extremo no editor de texto homônimo. Isso garante ao editor de texto Emacs a flexibilidade de permitir a construção de extensões poderosas, desde ferramentas avançadas para auxílio na codificação de programas, até a utilização do próprio editor de texto como um gerenciador de janelas do sistema operacional.</p>
<p><img src="img/elisp.png" alt="img" /></p>
<p><small>Editor de texto Emacs, editando código Emacs Lisp e Rust ao mesmo tempo, enquanto também navega por notícias via feed RSS.</small></p>
<p>A seguir, introduziremos as ideias principais do dialeto com atual maior relevância para você, que lê este texto: Majestic Lisp.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="majestic-lisp"><a class="header" href="#majestic-lisp">Majestic Lisp</a></h1>
<p>Majestic Lisp é o dialeto de Lisp implementado nesse livro. A implementação dele é baseada em cinco pontos principais, que definem as decisões de design da linguagem e da implementação:</p>
<ol>
<li>Performance não é um objetivo central, ainda que seja bem-vinda. Certamente é conveniente que o interpretador de Majestic Lisp tenha certas otimizações mas, dado que essa obra seja direcionada também para iniciantes em programação, não é necessário que o interpretador tenha uma performance a nível de uma linguagem usada para trabalhos profissionais;</li>
<li>A implementação busca ser didática ao máximo, e por isso foi feita utilizando <em>literate programming</em> <knuth1984> que aqui é traduzido livremente como <em>programação instruída</em>. Esse paradigma é discutido mais adiante;</li>
<li>A linguagem em si deve ser algo simples, em especial para aqueles que já tenham algum costume com outros dialetos de Lisp (como Scheme, Clojure e Common Lisp) – onde houver mudanças, elas deverão ser inteligíveis ao máximo;</li>
<li>A obra em si deve mostrar ao leitor que a criação de uma linguagem de programação e de seu interpretador, ainda que não seja uma atividade trivial, está longe de ser uma atividade <em>intangível</em>;</li>
<li>A linguagem em si foi pensada tanto para uso em computador quanto para uso <em>algébrico</em>, isto é, como uma notação que pode ser escrita à mão, sendo então uma ferramenta para explicar alguns conceitos de computação, quando pertinente.</li>
</ol>
<p>O primeiro ponto é evidente quando partimos do pressuposto de que o ideal para um programa é não realizar <em>otimização prematura</em>, o que não significa que não possamos usar boas ideias logo no início de um projeto. O software descrito nesse livro é algo acessível, do ponto de vista de um iniciante curioso em programação que já tenha uma certa prática.</p>
<p>A didática é essencial, e também é a causa determinante do segundo e terceiro pontos, também por razões de acessibilidade anteriormente descritas. Isso acaba por culminar na justificativa para o quarto ponto: um programador iniciante pode ficar facilmente intimidado pela ideia da construção da própria linguagem de programação. Todavia, um interpretador de uma linguagem é um programa como qualquer outro.</p>
<p>O quinto ponto vem inspirado diretamente em <iverson80>, que ressalta o uso da notação – nesse caso, a linguagem de programação em si – como uma ferramenta usada para raciocinar. Um Lisp simples, com regras facilmente compreensíveis, pode ser uma excelente ferramenta para explicar conceitos matemáticos envolvendo <em>Lambda Calculus</em> <church36a> ou os famosos <em>numerais de Church</em>, por exemplo.</p>
<p>Majestic Lisp possui uma sintaxe não muito diferente do que se encontra nos demais Lisps, no sentido de que também é baseada em <em>s-expressions</em>. Mas ela também possui suas próprias idiossincrasias que a difere dos demais dialetos. Posteriormente, observaremos adequadamente esses detalhes.</p>
<h1 id="design-do-interpretador"><a class="header" href="#design-do-interpretador">Design do Interpretador</a></h1>
<p>O interpretador de Majestic Lisp segue vagamente os moldes determinados por <sicp>, que definem o chamado <em>interpretador metacircular</em>.</p>
<p>Definimos este tipo de interpretador para uma linguagem de programação como sendo <em>circular</em>, por apresentar uma recursão mútua entre dois procedimentos principais: <code>eval</code> e <code>apply</code>. O uso do sufixo <em>meta</em> na denominação diz respeito à natureza metalinguística do mesmo: definimos o interpretador da linguagem em questão, usando a própria linguagem que se quer interpretar. Em <sicp>, define-se o interpretador de Scheme – um dialeto de Lisp – usando a própria linguagem Scheme.</p>
<p><img src="img/metacircular.png" alt="img" title="Recursão mútua em um interpretador metacircular." /></p>
<p>Esse tipo de abstração é extremamente poderosa, porque nos permite observar apenas o cerne do interpretador de uma linguagem de programação, sem demais considerações. Por exemplo, aqui assumimos que a <em>expressão</em> a ser interpretada já esteja em um formato que possa ser consumido pelo interpretador. Um programa de computador, normalmente, precisa ser digitado em um arquivo-texto, e esse arquivo então deverá ser processado para ser consumido pelo cerne do interpretador.</p>
<p>Para um <em>interpretador metacircular</em> de um dialeto de Lisp, esse processo é ignorável: pode-se tirar vantagem da própria estrutura da linguagem, que já realiza essa transformação. Assim, o programador só precisa preocupar-se com as implementações dos procedimentos <code>eval</code> e <code>apply</code>, as funções principais na descrição de um interpretador nesse modelo.</p>
<p>O interpretador de Majestic Lisp aqui descrito foi construido usando a linguagem de programação Rust. Sua descrição, portanto, não possui a característica de ser <em>metalinguística</em>, mas isso não significa que abandonaremos o modelo da circularidade mútua entre <code>eval</code> e <code>apply</code>. Ao invés disso, lidaremos com mais alguns passos extras, como a transormação de um arquivo-texto em uma estrutura que possa ser interpretada.</p>
<p><img src="img/modelo_geral.png" alt="img" title="Esquema ilustrativo do interpretador de Majestic Lisp." /></p>
<p>A Figura <a href="01-02-majestic-lisp.html#orgae803c8">17</a> descreve um esquema geral da arquitetura do interpretador de Majestic Lisp. Esse interpretador consiste de três <em>módulos</em> principais, além de um <em>componente global</em> trabalhando para a execução do interpretador.</p>
<p>O <em>componente global</em> de Majestic Lisp constitui-se, grosso modo, de duas partes importantes: o <em>núcleo</em> e o <em>estado global</em>.</p>
<p>O <em>núcleo</em> estipula certos <strong>axiomas</strong> e <strong>funções primitivas</strong> da linguagem, de forma que esses elementos e valores estejam disponíveis ao ambiente assim que o mesmo se inicia – o código em si poderá ser executado de forma subsequente.</p>
<p>O <em>estado global</em> encerra certas coleções vitais para a execução de um programa, podendo inclusive serem mutáveis. Essas coleções são:</p>
<ul>
<li><strong>Tabela de Símbolos:</strong> Um programa Lisp é composto principalmente por listas de símbolos, uma vez que Lisps são linguagens para computação simbólica. A tabela de símbolos é responsável por <em>manter referências</em> de símbolos, permitindo que sejam reutilizados ao longo do programa.</li>
<li><strong>Contexto Global:</strong> Em Majestic Lisp, trata-se de uma tabela que associa certos <em>símbolos</em> a <em>valores específicos</em>. Esse contexto é visível em todas as partes do programa, sendo esta a sua principal diferença com relação a um <em>contexto léxico</em>, que será melhor explorado em outro local.</li>
<li><strong>Tabela de <em>Streams</em>:</strong> Categoriza e gerencia <em>streams</em> abertos, que são estruturas muito similares a <em>descritores de arquivo</em> <a href="silberschatz2015">p. 445</a>. Em Majestic Lisp, os <em>streams</em> são responsáveis por toda a comunicação de <em>entrada</em> (por exemplo, fornecer o código ao Leitor) e <em>saída</em> (redirecionar o que será escrito na Tela ou em um arquivo). <em>Streams</em> são estruturas opacas que dependem de detalhes do sistema em que o programa do interpretador é executado.</li>
</ul>
<p>Resta agora enumerar os módulos principais do sistema. Eles são:</p>
<ol>
<li><strong>Impressão:</strong> Módulo responsável por formatar expressões em texto nativo, de forma que possam ser mostradas em formato humanamente legível. Como a impressão envolve percorrer e verificar símbolos, precisa ter acesso à tabela de símbolos do estado global;</li>
<li><strong>Leitor:</strong> Módulo responsável por tomar uma certa entrada em formato de texto nativo e transformá-lo em uma estrutura que possa ser processada pelo interpretador, normalmente conhecida como <em>árvore sintática abstrata</em> (AST). Como a leitura é um processo de transformação de símbolos em texto nativo para símbolos no ambiente Lisp, precisa ler e modificar a tabela de símbolos do estado global;</li>
<li><strong>Interpretador:</strong> O módulo mais importante do programa, sendo responsável pelo processo de <em>interpretação</em> de uma expressão em formato de AST</li>
</ol>
<p>Em um Lisp como Majestic Lisp, as <em>árvores sintáticas abstratas</em> são representadas usando <em>listas simplesmente ligadas</em>. Segundo <cormen-pt>, uma <em>lista ligada</em> é aquela cujos objetos estejam organizados linearmente, sendo esta ordem determinada por <em>ponteiros</em>, que aqui podemos compreender como referências ao ``próximo elemento''.</p>
<p>Isso introduz dois pontos de relevância: primeiramente, como Lisps são linguagens feitas para a manipulação de <em>listas simplesmente ligadas</em>, podemos representar internamente nossos programas usando o próprio <em>framework</em> da linguagem<sup><a id="fnr.1" class="footref" href="01-02-majestic-lisp.html#fn.1" role="doc-backlink">1</a></sup>. Isso significa que não será preciso implementar uma estrutura que sirva apenas para representar uma AST.</p>
<p>Segundo, como a AST pode ser representada diretamente em uma <em>lista</em>, isso significa que nossos programas poderiam ser <strong>manipulados através da própria linguagem</strong>. Esse é um conceito crucial de uma linguagem como Lisp, ainda que não seja exclusivo aos Lisps; a ele, damos o nome de <em>homoiconicidade</em>.</p>
<p>Podemos tirar muito proveito desse conceito; o leitor atento já terá percebido que podemos criar listas, durante a execução de um programa, que constituam também outros programas Lisp válidos.</p>
<h2 id="footnotes"><a class="header" href="#footnotes">Footnotes</a></h2>
<p><sup><a id="fn.1" class="footnum" href="01-02-majestic-lisp.html#fnr.1">1</a></sup> A melhor forma para compreendermos essa ideia é lembrando-nos de que, em algum ponto, precisamos de algo como uma ``matéria-prima'' para representarmos as listas em Majestic Lisp. Se tivermos uma forma simples de representação de <em>listas simplesmente ligadas</em>, então basta que, durante o processo de conversão do programa, criemos <em>listas</em> cujos elementos sejam <em>símbolos</em> ou outras <em>sub-listas</em>. Esse processo será melhor discutido mais tarde.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sobre-programação-instruída"><a class="header" href="#sobre-programação-instruída">Sobre Programação Instruída</a></h1>
<p>Para garantir a reproducibilidade do projeto, optei aqui por utilizar o conceito de <em>literate programming</em>, como demonstrado por <knuth1984>, que aqui traduzo livremente como <em>programação instruída</em>, dado seu objetivo de instruir o leitor, passo-a-passo, no desenvolvimento de uma aplicação.</p>
<p>Este interpretador foi inteiramente escrito utilizando o formato de texto Org, no editor de texto Emacs. De acordo com o website do Org<sup><a id="fnr.1" class="footref" href="01-03-sobre-programacao-instruida.html#fn.1" role="doc-backlink">1</a></sup>, trata-se de ``um formato para realizar anotações, manter listas de tarefas a serem feitas, planejar projetos, e criar documentos com um sistema de texto-plano rápido e efetivo''. A prosa é escrita ao longo do arquivo, e são inseridos blocos de código que foram configurados para serem escritos em seus respectivos e apropriados arquivos posteriormente.</p>
<p>O código possui estrutura e organização que podem não seguir fielmente o conteúdo deste texto. Sendo assim, tal código é exportado posteriormente, através de um processo conhecido como <em>entrelaçamento</em> (<em>tangling</em>). Ao utilizar este método, espero manter uma aplicação onde o entendimento do que está sendo escrito venha antes do código em si, de forma que o leitor possa timar e analisar partes do código com base na prosa que as acompanha.</p>
<h2 id="footnotes-1"><a class="header" href="#footnotes-1">Footnotes</a></h2>
<p><sup><a id="fn.1" class="footnum" href="01-03-sobre-programacao-instruida.html#fnr.1">1</a></sup> <a href="https://orgmode.org/">https://orgmode.org/</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="como-ler-este-documento"><a class="header" href="#como-ler-este-documento">Como ler este documento</a></h1>
<p>Como citado anteriormente, este documento funciona de forma dupla, constituindo-se de duas partes: primeiro, uma prosa com blocos de código nela inseridos; segundo, o <em>entrelaçamento</em> dos blocos de código em seus respectivos arquivos, o que compõe o texto do código do interpretador de Majestic Lisp.</p>
<p>A linguagem utilizada na construção do interpretador é a linguagem Rust<sup><a id="fnr.1" class="footref" href="01-04-como-ler-este-documento.html#fn.1" role="doc-backlink">1</a></sup>, uma linguagem construída para <em>programação de sistemas</em>. Usufruiremos dos recursos de Rust para construir o interpretador, mas o livro não é um tutorial dessa linguagem; dito isso, os blocos de código em Rust foram construídos com cuidado para que possam ser o quanto mais acessíveis for possível para leigos nessa linguagem.</p>
<p>Blocos de implementação de métodos em Rust (iniciados pela palavra-chave <code>impl</code>) foram divididos em certas partes, de forma que pode haver redundância em sua declaração. Isso foi feito para que cada método possa ser estudado e descrito separadamente, onde esse procedimento for pertinente.</p>
<p>No caso dos exemplos envolvendo código em Majestic Lisp, algumas vezes precisaremos simular entrada e saída de comandos em uma estrutura chamada REPL. O REPL (acrônimo para <em>read, eval, print, loop</em>) nada mais é que a ideia de um console interativo, onde o usuário digitará uma entrada, e em seguida o resultado do processamento dessa entrada será impresso logo abaixo.</p>
<p>Seguiremos um formato de descrição do REPL onde a entrada do usuário é precedida por um caractere <code>&gt;</code>. O resultado da operação virá logo abaixo, sem um recuo. Em entradas multilinha da parte do usuário, estas respeitarão o recuo produzido pelo caractere <code>&gt;</code>.</p>
<pre><code>&gt; entrada do usuário
resultado

&gt; entrada do usuário
  com múltiplas linhas
resultado
</code></pre>
<h2 id="footnotes-2"><a class="header" href="#footnotes-2">Footnotes</a></h2>
<p><sup><a id="fn.1" class="footnum" href="01-04-como-ler-este-documento.html#fnr.1">1</a></sup> <a href="https://www.rust-lang.org/">https://www.rust-lang.org/</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
